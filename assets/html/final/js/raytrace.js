rooms.raytrace=function(){lib3D(),description='\n<small>\n    <p>\n    <b>Atmospheric parameters</b>\n    <br> <input type="range" id="tod" value="20",min="1",max="100"> Time of Day\n    <br> <input type="range" id="fi"  value="10",min="1",max="100"> Fog Intensity\n    <br> <input type="range" id="ci"  value="10",min="1",max="100"> Cloud Intensity\n    <br> <input type="checkbox" id="cbx_0" onclick="onVolumetricClicked()"> Volumetric Light\n    <br> <input type="checkbox" id="cbx_1"   onclick="onVisualizeClicked()"> Visualize Sphere\n</small>\n',code={init:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   // DEFINE INTERACTIVE\n\n   S.visualizeSphere = false;\n   S.vl = false;\n   S.pitch = 0.;\n   S.yaw = 0.;\n   S.mouseX = 0.;\n   S.mouseY = 0.;\n   S.cPos = [0., 2.5, 10.];\n   S.cDir = [0., 0. ,  0.];\n\n   // DEFINE NUMBER OF LIGHTS\n\n   S.nL = 1;\n\n   // DEFINE MATERIALS TO BE RENDERED VIA PHONG REFLECTANCE MODEL\n\n   let materials = [\n      [.15,.05,.025,0, .3,.1,.05,0, .6,.2,.1,3, 0,0,0,0], // COPPER\n      [.25,.15,.025,0, .5,.3,.05,0, 1,.6,.1,6,  0,0,0,0], // GOLD\n      [.25,0,0,0,      .5,0,0,0,    2,2,2,20,   0,0,0,0], // PLASTIC\n      [.05,.05,.05,0,  .1,.1,.1,0,  1,1,1,5,    0,0,0,0], // LEAD\n      [.1,.1,.1,0,     .1,.1,.1,0,  1,1,1,5,    0,0,0,0], // SILVER\n   ];\n\n   S.nS = 100;\n   S.sPos = [];\n   S.sRadius = [];\n   for (let n = 0 ; n < S.nS ; n++) {\n      S.sPos.push([ .03 * S.nS * (Math.random() - .5),\n                    2.,\n                    .03 * S.nS * (Math.random() - .5) ]);\n      S.sRadius.push([.5 + .5 * Math.random(), Math.random(), 1.]);\n   }\n",fragment:"\nS.setFragmentShader(`\n\n   // DECLARE CONSTANTS, UNIFORMS, VARYING VARIABLES\n   \n   const int nS = ` + S.nS + `;\n   const int nL = ` + S.nL + `;\n\n   uniform vec3 uCamPos;\n   uniform vec3 uCamDir;\n   uniform float uTime;\n   uniform float uTOD;\n   uniform vec3 uBgColor;\n   uniform vec3 uLd[nL];\n   uniform vec3 uLc[nL];\n\n   uniform float uLi;\n   uniform float uFi;\n\n   varying vec3 vPos;\n\n   uniform vec4 uS[nS];\n   uniform float uV;\n   uniform float uVL;\n\n   // DEFINE CAMERA FOCAL LENGTH\n\n   float fl = 3.;\n\n   // COMPUTE REFRACTION RAY\n\n   vec3 computeRefraction(vec3 W1, vec3 N, float rFactor) {\n      vec3 C1 = N * dot(W1, N);\n      vec3 S1 = W1 - C1;\n      float theta1 = length(S1);\n      float theta2 = asin(theta1 * rFactor);\n      vec3 C2 = C1 * cos(theta2) / cos(theta1);\n      vec3 S2 = S1 * sin(theta2) / sin(theta1);\n      return C2 + S2;\n   }\n\n   // COMPUTE EXPONENTIAL FOG\n\n   vec3 expFog(vec3 inColor, vec3 fogColor, float t, float fogIntensity) {\n      t = max(1., t);\n      float a = pow(1. - fogIntensity, log(t));\n      return mix(fogColor * uLi, inColor, a);\n   }\n\n   // FOLLOWING RENDER ATMOSPHERIC PHENOMENAL\n\n   // PSEUDO SUN RAY TRACING\n\n   float raySun(vec3 V, vec3 W) {\n      vec3 sunPos = uLd[0] * 990.;\n      V -= sunPos.xyz;\n      V += .01 * W;\n      float b = dot(V, W);\n      float d = b * b - dot(V, V) + 100.;\n      return d < 0. ? -1. : -b - sqrt(d);\n   }\n\n   // RETURN THE COLOR OF THE LIGHT\n\n   vec3 shadeSun(vec3 V, vec3 W, float t) {\n      return uLc[0] * 1.5;\n   }\n\n   // RAY MARCHING VOLUMETRIC LIGHT\n\n   float rayRoughSphere(vec3 V, vec3 W, vec4 S) {\n      V -= S.xyz;\n      V += .01 * W;\n      float b = dot(V, W);\n      float r = S.w / 2.;\n      float d = b * b - dot(V, V) + r * r;\n      return d < 0. ? -1. : -b - sqrt(d);\n   }\n\n   vec3 marchVolumetricLight(vec3 V, vec3 W, float t, vec3 inColor) {\n      float d = t / 50.;\n      if (d > .5) d = .5;\n      float step = 0.;\n      vec3 P = V;\n      bool detect = false;\n\n      for (int i = 0; i < 50; i++) {\n         if (!detect && step < t) {\n            step += d;\n            P += W * d;\n            float r = 10.;\n\n            for (int j = 0; j < nS; j++) {\n               if (!detect) {\n                  float rt = rayRoughSphere(P, uLd[0], uS[j]);\n                  if (rt > 0. && rt < r) {\n                     r = rt;\n                     detect = true;\n                  }\n               }\n            }\n         }\n      }\n\n      if (detect) return inColor / 1.1;\n      return inColor;\n   }\n\n   // COMPUTE AND SHADE THE NOISE-BASED CLOUDS USING RAY-MARCHING\n\n   float getNoiseRadius(vec3 P, float r) {\n      float n = .5 + .5 * abs(noise(P * 1. - uTime * .02));\n      n *= (.5 + .5 * abs(noise(P * 10. + uTime * .04)));\n\n      n *= 8.;\n      n = floor(n);\n      n /= 8.;\n\n      return r * n;\n   }\n\n   float rayNoiseSphere(vec3 V, vec3 W, vec4 S) {\n      vec3 oV = V;\n      V -= S.xyz;\n      V += .01 * W;\n      float b = dot(V, W);\n      float r = S.w;\n      float d = b * b - dot(V, V) + r * r;\n\n      if (d < 0.) return -1.;\n\n      float t = -b - sqrt(d);\n\n      if (uV > 0.) return t;\n      float step = 0.;\n      float cnt = 0.;\n\n      for (int i = 0; i < 4; i++) {\n         step = distance(oV + t * W, S.xyz) - getNoiseRadius(oV + t * W, S.w);\n         t += step;\n\n         if (step > 0.) cnt += 1.;\n      }\n\n      if (distance(oV + t * W, S.xyz) > S.w / 1.2 && cnt > 3.) return -1.;\n      return t;\n   }\n\n   vec4 shadeCloud(vec3 V, vec3 W, vec3 inColor) {\n      float t = 1000.;\n\n      vec3 P;\n      vec3 N = vec3(0.);\n      float s = 0.;\n      float radius = 0.;\n      for (int i = 0; i < nS; i++) {\n         float tS = rayNoiseSphere(V, W, uS[i]);\n         if (tS > 0. && tS < t) {\n            P = V + tS * W;\n            t = tS;\n            radius = uS[i].w;\n         }\n      }\n\n      for (int i = 0; i < nS; i++) {\n         N += (P - uS[i].xyz) * (1. / distance(P, uS[i].xyz)) * uS[i].w;\n         float ms = rayRoughSphere(P, uLd[0], uS[i]);\n         if (ms > 0.) s += ms;\n      }\n\n      N = normalize(N);\n\n      vec3 c = vec3(min(.5, 1. / s));\n      c += max(0.,dot(N, uLd[0])) * uLc[0];\n\n      if (t < 1000.)\n         return vec4(c, t);\n\n      return vec4(-1.);\n   }\n\n   // COMPUTE SURFACE HEIGHT USING NOISE\n\n   float computeSurfaceHeight(vec3 surfacePoint) {\n      float n = noise(surfacePoint * 8. + vec3(uTime, uTime, 0.));\n      n += noise(surfacePoint * 16. + vec3(uTime, -uTime, 0.));\n\n      return n / 100.;\n   }\n\n   // COMPUTE NORMAL USING HEIGHTMAP DATA\n\n   vec3 computeSurfaceNormal(vec3 surfacePoint) {\n      vec3 s1 = vec3(surfacePoint.x - .001, surfacePoint.y, surfacePoint.z);\n      vec3 s2 = vec3(surfacePoint.x + .001, surfacePoint.y, surfacePoint.z);\n      vec3 s3 = vec3(surfacePoint.x, surfacePoint.y, surfacePoint.z - .001);\n      vec3 s4 = vec3(surfacePoint.x, surfacePoint.y, surfacePoint.z + .001);\n\n      vec3 h1 = vec3(surfacePoint.x - .001,\n                     computeSurfaceHeight(s1),\n                     surfacePoint.z);\n      vec3 h2 = vec3(surfacePoint.x + .001,\n                     computeSurfaceHeight(s2),\n                     surfacePoint.z);\n      vec3 h3 = vec3(surfacePoint.x,\n                     computeSurfaceHeight(s3),\n                     surfacePoint.z - .001);\n      vec3 h4 = vec3(surfacePoint.x,\n                     computeSurfaceHeight(s4),\n                     surfacePoint.z + .001);\n\n      vec3 l1 = h1 - h2;\n      vec3 l2 = h3 - h4;\n\n      // FIND THE CROSS PRODUCT OF L1 AND L2\n\n      vec3 n = vec3(l1.y * l2.z - l1.z * l2.y, \n                    l1.z * l2.x - l1.x * l2.z,\n                    l1.x * l2.y - l1.y * l2.x);\n\n      if (n.y < 0.) n = -n;\n\n      return normalize(n);\n   }\n\n   // TRACE AND SHADE THE SEA FLOOR\n\n   float rayFloor(vec3 V, vec3 W, float t) {\n      if (V.y + t * W.y < -1.) return (-1. - V.y) / W.y;\n      else return -1.;\n   }\n\n   // COMPUTE CAUSTICS USING SEA SURFACE NOISE\n\n   vec3 shadeFloor(vec3 P) {\n      float caustics = abs(noise((P + uLd[0]) * 3. - vec3(uTime * .5)));\n      caustics += abs(noise((P + uLd[0]) * 5. + vec3(uTime * .5)));\n      caustics = 1. - caustics;\n      caustics = pow(caustics, 4.);\n      caustics *= uLi;\n      return vec3(.5 + caustics);\n   }\n\n   // TRACE A PLANE SURFACE BY HEIGHT\n\n   float raySurface(vec3 V, vec3 W, float t) {\n      if (V.y + t * W.y < computeSurfaceHeight(V + t * W)) return -V.y / W.y;\n      else return -1.;\n   }\n\n   // TRACE A PLANE SURFACE BY HEIGHT UNDERWATER\n\n   float raySurfaceUnder(vec3 V, vec3 W, float t) {\n      if (V.y + t * W.y > computeSurfaceHeight(V + t * W)) return -V.y / W.y;\n      else return -1.;\n   }\n\n   // SHADE AN OCEAN SURFACE\n\n   vec3 shadeSurface(vec3 W, vec3 P, float t) {\n      vec3 c = expFog(uBgColor * .5, uLc[0] * .2, 100., uFi);\n      vec3 N = computeSurfaceNormal(P);\n\n      vec3 diffuse = vec3(.1);\n      vec3 specular = vec3(1.);\n\n      for (int l = 0 ; l < nL ; l++) {\n         vec3 R = 2. * dot(N, uLd[l]) * N - uLd[l];\n         c += uLc[l] * (diffuse * max(0.,dot(N, uLd[l])) * uLi\n                      + specular * pow(max(0., dot(R, W)), 20.)) * uLi;\n      }\n\n      // WATER REFRACTION\n\n      vec3 rfc = vec3(0.);\n      float rftMin = 10.;\n\n      if (t < 10.) {\n         vec3 rDir = computeRefraction(W, N, .5);\n      }\n\n      if (rftMin < 10.) c = mix(rfc, c, 1. - rftMin / 10.);\n\n      // WATER REFLECTION\n\n      vec3 R = 2. * dot(N, -W) * N + W;\n      float rtMin = 10000.;\n      vec3 rc = vec3(0.);\n\n      float rS = raySun(P, R);\n      if (rS > 0. && rS < rtMin) {\n         rtMin = rS;\n         rc = shadeSun(P, R, rtMin) * uLc[0];\n      }\n\n      vec4 rCl = shadeCloud(P, R, c);\n      if (rCl.a > 0. && rCl.a < rtMin) {\n         rtMin = rCl.w;\n         rc = rCl.rgb;\n      }\n      \n      if (rtMin < 10000.) c = mix(c, rc, .5);\n\n      c *= uLi;\n\n      return c;\n   }\n\n   // SHADE AN OCEAN SURFACE UNDERWATER\n\n   vec3 shadeSurfaceUnder(vec3 W, vec3 P, float t) {\n      vec3 c = expFog(uBgColor * .5, uLc[0] * .2, 100., uFi);\n      vec3 N = -computeSurfaceNormal(P);\n\n      vec3 diffuse = vec3(.1);\n      vec3 specular = vec3(.2);\n\n      for (int l = 0 ; l < nL ; l++) {\n         vec3 R = 2. * dot(N, uLd[l]) * N - uLd[l];\n         c += uLc[l] * (diffuse * max(0.,dot(N, uLd[l])) * uLi\n                      + specular * pow(max(0., dot(R, W)), 20.)) * uLi;\n      }\n\n      // WATER REFRACTION\n\n      vec3 rfc = vec3(0.);\n      float rftMin = 10.;\n\n      if (t < 10.) {\n         vec3 rDir = computeRefraction(W, N, .5);\n      }\n\n      if (rftMin < 10.) c = mix(rfc, c, 1. - rftMin / 10.);\n\n      c *= uLi;\n\n      return c;\n   }\n\n   // GENERATE TERRAIN HEIGHT USING NOISE\n\n   float getTerrainHeight(float x, float z) {\n      vec3 P = vec3(x, 0., z);\n\n      float h = noise(P * .02);\n      h += noise(P * .01);\n\n      return h;\n   }\n\n   // TRACE A NOISE-GENERATED TERRAIN USING RAY-MARCHING\n\n   float rayTerrain(vec3 V, vec3 W) {\n      float t = -V.z / W.z;\n\n      if (t > 1000. || t < 0.) return -1.;\n\n      vec3 s = V + t * W;\n\n      float x1 = mod(s.x, 1.);\n      float z1 = mod(s.z, 1.);\n\n      float x2 = x1 + 1.;\n      float z2 = z1 + 1.;\n\n      for (int i = 0; i < 1000; i++) {\n         if (t > 0.) {\n            s = V + t * W;\n\n            x1 = mod(s.x, 1.);\n            z1 = mod(s.z, 1.);\n\n            x2 = x1 + 1.;\n            z2 = z1 + 1.;\n\n            t -= 1.;\n\n            float minHeight = min(min(getTerrainHeight(x1, z1),\n                                      getTerrainHeight(x1, z2)),\n                                  min(getTerrainHeight(x2, z1),\n                                      getTerrainHeight(x2, z2)));\n            if (minHeight < getTerrainHeight(s.x, s.z)) {\n               return t;\n            }\n         }\n      }\n\n      return -1.;\n   }\n\n   void main() {\n\n      vec3 color;\n      vec3 V = uCamPos + vec3(0., 0., fl);\n      vec3 W = normalize(vec3(vPos.xy, -fl));\n\n      // BACKGROUND COLOR IS THE DEFAULT COLOR\n\n      color = uBgColor * uLi;\n\n      // DEFINE RAY INTO SCENE FOR THIS PIXEL\n\n      float tMin = 1000.;\n\n      float tSun = raySun(V, W);\n      if (tSun > 0. && tSun < tMin) {\n         color += shadeSun(V, W, tSun);\n         tMin = tSun;\n      }\n\n      // RAY TRACE SEA SURFACE\n\n      float tS = raySurface(V, W, tMin);\n\n      if (tS > 0. && tS < tMin) {\n         tMin = tS;\n         color = shadeSurface(W, V + tS * W, tMin);\n      }\n\n      // RAY MARCH AND SHADE THE CLOUDS\n\n      vec4 tC = shadeCloud(V, W, color);\n      if (tC.a > 0. && tC.a < tMin) {\n         color = tC.rgb;\n         tMin = tC.a;\n      }\n      else if (uVL > 0.) {\n         color = marchVolumetricLight(V, W, tMin, color);\n      }\n         \n      // ADD FOG LAYER\n\n      color = expFog(color, uLc[0], tMin, uFi);\n\n      // SET PIXEL COLOR\n\n      gl_FragColor = vec4(sqrt(color), 1.);\n   }\n`);\n",vertex:"\nS.setVertexShader(`\n\n   attribute vec3 aPos;\n   varying   vec3 vPos;\n\n   void main() {\n      vPos = aPos;\n      gl_Position = vec4(aPos, 1.);\n   }\n\n`)\n",render:"\n\n   // HANDY DANDY VECTOR LIBRARY\n\n   let add = (a,b) => [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];\n   let dot = (a,b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n   let norm = v => Math.sqrt(dot(v,v));\n   let normalize = v => {\n      let s = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n      return [ v[0]/s, v[1]/s, v[2]/s ];\n   }\n   let scale = (v,s) => [ s * v[0], s * v[1], s * v[2] ];\n   let subtract = (a,b) => [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];\n\n   // MATRIX LIBRARY\n\n   let matrixIdentity = () => [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n\n   let matrixInverse = function(src) {\n   let dst = [], det = 0, cofactor = (c, r) => {\n      let s = (i, j) => src[c+i & 3 | (r+j & 3) << 2];\n      return (c+r & 1 ? -1 : 1) * ( (s(1,1) * (s(2,2) * s(3,3) - s(3,2) * s(2,3)))\n                                 - (s(2,1) * (s(1,2) * s(3,3) - s(3,2) * s(1,3)))\n                                 + (s(3,1) * (s(1,2) * s(2,3) - s(2,2) * s(1,3))) );\n      }\n      for (let n = 0 ; n < 16 ; n++) dst.push(cofactor(n >> 2, n & 3));\n      for (let n = 0 ; n <  4 ; n++) det += src[n] * dst[n << 2];\n      for (let n = 0 ; n < 16 ; n++) dst[n] /= det;\n      return dst;\n   }\n\n   let matrixMultiply = function(a, b) {\n      let dst = [];\n      for (let n = 0 ; n < 16 ; n++)\n         dst.push( a[n&3     ] * b[n&12    ] +\n                  a[n&3 |  4] * b[n&12 | 1] +\n                  a[n&3 |  8] * b[n&12 | 2] +\n                  a[n&3 | 12] * b[n&12 | 3] );\n      return dst;\n   }\n\n   let matrixRotx = t => {\n      let c = Math.cos(t), s = Math.sin(t);\n      return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1];\n   }\n\n   let matrixRoty = t => {\n      let c = Math.cos(t), s = Math.sin(t);\n      return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1];\n   }\n\n   let matrixRotz = t => {\n      let c = Math.cos(t), s = Math.sin(t);\n      return [c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1];\n   }\n\n   let matrixScale = (x,y,z) => [x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1];\n\n   let matrixTranslate = (x,y,z) => [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1];\n\n   let matrixTranspose = function(m) {\n      return [ m[0],m[4],m[ 8],m[12],\n               m[1],m[5],m[ 9],m[13],\n               m[2],m[6],m[10],m[14],\n               m[3],m[7],m[11],m[15] ];\n   }\n\n   let mTranslate = (x,y,z, M) => matrixMultiply(M, matrixTranslate(x,y,z));\n   let mRotx      = (theta, M) => matrixMultiply(M, matrixRotx(theta));\n   let mRoty      = (theta, M) => matrixMultiply(M, matrixRoty(theta));\n   let mRotz      = (theta, M) => matrixMultiply(M, matrixRotz(theta));\n   let mScale     = (x,y,z, M) => matrixMultiply(M, matrixScale(x,y,z));\n\n   // SEND CAMERA INFO TO GPU\n\n   S.setUniform('3fv', 'uCamPos', S.cPos);\n\n   S.cDir = [Math.sin(S.yaw), Math.sin(S.pitch), Math.cos(S.yaw)];\n\n   S.setUniform('3fv', 'uCamDir', S.cDir);\n\n   // GET ATMOSPHERIC DATA\n\n   let timeOfDay = tod.value;\n   let ldZ = 1. - timeOfDay / 50.;\n   let ldY = Math.sin((timeOfDay / 100.) * Math.PI);\n\n   let lcG = .5 + .5 * Math.sin((timeOfDay / 100.) * Math.PI);\n   let lcB = Math.sin((timeOfDay / 100.) * Math.PI);\n\n   // SEND LIGHT SOURCE DATA TO GPU\n\n   let ldData = [ normalize([.2,ldY,ldZ]) ];\n   let lIntensity = 1. + .5 * Math.sin((timeOfDay / 100.) * Math.PI);\n\n   let lcData = [1,lcG,lcB];\n\n   S.setUniform('3fv', 'uLd', ldData.flat());\n   S.setUniform('3fv', 'uLc', lcData);\n   S.setUniform('1f', 'uLi', lIntensity);\n\n   // CHANGE SPHERE POSITION RADIUS\n\n   S.nS = Math.floor(ci.value);\n   if (S.nS == 0) S.nS = 1;\n\n   for (let n = 0; n < S.nS; n++) {\n      S.sRadius[n][2] = (1. + .1 * Math.sin(time * S.sRadius[n][1]) * S.sRadius[n][0])\n                         * Math.min(1., ci.value / 10.);\n   }\n\n   // SEND SPHERES DATA TO GPU\n\n   let sData = [];\n   for (let n = 0; n < S.nS; n++)\n      sData.push(S.sPos[n], S.sRadius[n][2]);\n   S.setUniform('4fv', 'uS', sData.flat());\n\n   // SEND FOG DATA TO GPU\n\n   let fogIntensity = fi.value / 100.;\n\n   S.setUniform('1f', 'uFi', fogIntensity);\n\n   // SET VISUALIZE DATA TO GPU\n\n   let visualize = 0.;\n   if (S.visualizeSphere) visualize = 1.;\n\n   S.setUniform('1f', 'uV', visualize);\n\n   // SET VISUALIZE DATA TO GPU\n\n   let voll = 0.;\n   if (S.vl) voll = 1.;\n\n   S.setUniform('1f', 'uVL', voll);\n\n   // SEND ANIMATION TIME TO GPU\n\n   S.setUniform('1f', 'uTime', time);\n\n   //S.setUniform('Matrix4fv', 'uSm', false, S.material.flat());\n\n   // SEND BACKGROUND COLOR TO GPU\n\n   S.setUniform('3fv', 'uBgColor', [ .15,.2,.85 ]);\n\n   // RENDER THIS ANIMATION FRAME\n\n   S.gl.drawArrays(S.gl.TRIANGLE_STRIP, 0, 4);\n",events:"\n\n  onDrag = (x,y) => {\n      if (x > S.mouseX) S.yaw += .01;\n      else S.yaw -= .01;\n\n      if (y > S.mouseY) S.pitch += .01;\n      else S.pitch -= .01;\n\n      S.mouseX = x;\n      S.mouseY = y;\n  }\n\n  onKeyPress = key => {\n\n      // FORWARD\n      if (key == 87) {\n         S.cPos[2] -= .1;\n      }\n      // BACKWARD\n      else if (key == 83) {\n         S.cPos[2] += .1;\n      }\n      // LEFT\n      else if (key == 65) {\n         S.cPos[0] -= .1;\n      }\n      // RIGHT\n      else if (key == 68) {\n         S.cPos[0] += .1;\n      }\n      // UP\n      else if (key == 81) {\n         S.cPos[1] += .1;\n      }\n      // DOWN\n      else if (key == 69) {\n         S.cPos[1] = Math.max(S.cPos[1] - .1, .1);\n      }\n\n      console.log(key);\n  }\n\n  onVisualizeClicked = () => {\n      S.visualizeSphere = !S.visualizeSphere;\n  }\n\n  onVolumetricClicked = () => {\n      S.vl = !S.vl;\n  }\n"}};